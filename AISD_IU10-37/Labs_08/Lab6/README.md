# Выполнил - Попков Георгий Вячеславович 
# Группа - ИУ10-37
# Лабораторная работа 6. Итеративные и рекурсивные алгоритмы

**Цель работы:** изучить рекурсивные алгоритмы и рекурсивные структуры данных; научиться проводить анализ итеративных и рекурсивных процедур; исследовать эффективность итеративных и  рекурсивных процедур при реализации на ПЭВМ.

---

# Номер 1
 
Задача состоит в том, чтобы реализовать рекурсивный алгоритм для вычисления числа способов представления числа \( M \) в виде суммы чисел, каждое из которых не превосходит \( N \). Для этого используется рекуррентное соотношение, которое определяет функцию \( Q_{M,N} \) как количество таких разложений.

Давайте подробно разберем, что нам нужно сделать и как это реализовать:

### Определения и пояснения:

Рекуррентное соотношение для \( Q_{M,N} \) звучит так:

$$ Q_{M,N} =  
\left\{
  \begin{array}{ll}
    1, & \text{если} M = 1, \text{при всех} N,\\
    1, & \text{если} N = 1, \text{при всех} M,\\
    Q_{M,M}, & \text{M < N}, \\
    1 + Q_{M,M-1}, & \text{M = N}, \\
     Q_{M,N-1} + Q_{M-N,N}, & \text{M > N}, \\
  \end{array}
\right.$$

### Пояснение к каждому случаю:

1. **\( M = 1 \)**: Существует только один способ представить единицу как сумму, независимо от \( N \), — это просто \( 1 \).
2. **\( N = 1 \)**: Существует только один способ представить любое число \( M \) как сумму единиц.
3. **\( M < N \)**: Если \( M \) меньше \( N \), то максимальное число в разложении обязательно равно \( M \), и нужно просто вычислить \( Q_{M,M} \).
4. **\( M = N \)**: В случае равенства \( M \) и \( N \) существует один способ — это представить \( M \) как сумму из одного слагаемого \( M \). Далее добавляется способ разложения, включающий числа, меньшие \( M \), то есть \( Q_{M,M-1} \).
5. **\( M > N \)**: В этом случае разложения можно разделить на два типа:
    - Без числа \( N \) в разложении, что дает \( Q_{M, N-1} \).
    - С числом \( N \) в разложении, что даёт \( Q_{M-N, N} \).

### Реализация алгоритма:

Пример реализации рекурсивного решения на Python:

```python
def Q(M, N):
    # Базовые случаи
    if M == 1:
        return 1
    if N == 1:
        return 1
    if M < N:
        return Q(M, M)
    if M == N:
        return 1 + Q(M, M-1)
    
    # Рекурсивный случай
    return Q(M, N-1) + Q(M-N, N)

# Пример использования:
M = 5
N = 3
print(Q(M, N))  # Выводит количество разложений числа 5 с числами, не превышающими 3
```

### Пояснение реализации:

1. **Базовые случаи**: Проверяем, когда \( M = 1 \) или \( N = 1 \), и возвращаем 1, как это указано в определении.
2. **Когда \( M < N \)**: В этом случае нам нужно использовать \( Q(M, M) \), потому что максимальное слагаемое не может быть больше \( M \).
3. **Когда \( M = N \)**: Добавляем 1 (представление числа \( M \) как одно слагаемое) и рекурсивно вычисляем \( Q(M, M-1) \).
4. **Когда \( M > N \)**: Разбиваем задачу на два подзадачи, как указано в рекуррентной формуле: \( Q(M, N-1) + Q(M-N, N) \).

### Пример работы:

Для \( M = 5 \) и \( N = 3 \) алгоритм сначала ищет все возможные разложения числа 5 с числами, не превосходящими 3. Это будет включать разложения типа:
- \( 3 + 2 \)
- \( 3 + 1 + 1 \)
- \( 2 + 2 + 1 \)
- \( 1 + 1 + 1 + 1 + 1 \)

Таким образом, результат будет \( 5 \).

Этот алгоритм работает по рекурсивному принципу и находит все разложения числа \( M \) с числами, не превосходящими \( N \), по указанной формуле.

---

# Номер 2

Чтобы реализовать алгоритм для вычисления \( Q_{M,N} \) без рекурсии, можно использовать динамическое программирование. Вместо того, чтобы вычислять значение \( Q_{M,N} \) рекурсивно, мы будем заполнять таблицу значений для всех пар \( (M, N) \) с помощью итераций.

### Идея подхода:

Мы создадим двумерный массив \( dp[M+1][N+1] \), где \( dp[m][n] \) будет хранить значение \( Q_{m,n} \). Начнем с базовых случаев, указанных в рекуррентной формуле, и постепенно будем заполнять таблицу.

### Пошаговое заполнение таблицы:

1. **Базовые случаи**:
   - \( dp[1][n] = 1 \) для всех \( n \), потому что есть только один способ разложить 1 — это взять одну единицу.
   - \( dp[m][1] = 1 \) для всех \( m \), потому что разложить любое число \( m \) с помощью только единиц можно только одним способом.
   
2. **Основной рекуррентный случай**:
   - Если \( m < n \), то \( dp[m][n] = dp[m][m] \).
   - Если \( m = n \), то \( dp[m][n] = 1 + dp[m][m-1] \).
   - Если \( m > n \), то \( dp[m][n] = dp[m][n-1] + dp[m-n][n] \).

### Реализация алгоритма:

```python
def Q(M, N):
    # Создаем таблицу для хранения значений Q[m][n]
    dp = [[0] * (N + 1) for _ in range(M + 1)]
    
    # Заполнение базовых случаев
    for n in range(N + 1):
        dp[1][n] = 1  # Для любого N, Q(1, N) = 1
    
    for m in range(M + 1):
        dp[m][1] = 1  # Для любого M, Q(M, 1) = 1

    # Заполнение таблицы по рекуррентной формуле
    for m in range(2, M + 1):
        for n in range(2, N + 1):
            if m < n:
                dp[m][n] = dp[m][m]  # Если M < N, то Q(M, N) = Q(M, M)
            elif m == n:
                dp[m][n] = 1 + dp[m][m - 1]  # Если M = N, то Q(M, N) = 1 + Q(M, M-1)
            else:
                dp[m][n] = dp[m][n - 1] + dp[m - n][n]  # Если M > N, то Q(M, N) = Q(M, N-1) + Q(M-N, N)

    # Ответ для Q(M, N) будет храниться в dp[M][N]
    return dp[M][N]

# Пример использования:
M = 5
N = 3
print(Q(M, N))  # Выводит количество разложений числа 5 с числами, не превосходящими 3
```

### Пояснение:

1. **Инициализация таблицы**: Мы создаем таблицу \( dp \) размером \( (M+1) \times (N+1) \), где каждый элемент будет хранить значение \( Q_{m,n} \).
   
2. **Заполнение базовых случаев**:
   - Для любого \( n \), \( dp[1][n] = 1 \), так как число 1 можно разложить только как одну единицу.
   - Для любого \( m \), \( dp[m][1] = 1 \), так как любое число \( m \) можно разложить только как сумму из единиц.

3. **Заполнение таблицы по рекуррентным формулам**:
   - Для каждого \( m \) и \( n \) мы вычисляем значение \( dp[m][n] \) в зависимости от того, как оно вычисляется по рекуррентной формуле:
     - Если \( m < n \), то \( dp[m][n] = dp[m][m] \), так как максимальное слагаемое не может превышать \( m \).
     - Если \( m = n \), то \( dp[m][n] = 1 + dp[m][m-1] \).
     - Если \( m > n \), то \( dp[m][n] = dp[m][n-1] + dp[m-n][n] \).

4. **Результат**: После того как таблица будет полностью заполнена, результат для \( Q(M, N) \) будет храниться в \( dp[M][N] \).

### Пример работы:

Для \( M = 5 \) и \( N = 3 \), алгоритм будет заполнять таблицу значений для всех пар \( (m, n) \), начиная от \( (1,1) \), \( (1,2) \), и так далее, в конечном итоге вычисляя \( dp[5][3] \), который и будет искомым числом разложений.

### Оценка сложности:

- **Время**: Мы заполняем таблицу размером \( M \times N \), и каждый элемент вычисляется за \( O(1) \). Таким образом, общая сложность алгоритма — \( O(M \times N) \).
- **Память**: Мы используем двумерную таблицу размером \( M \times N \), так что сложность по памяти — \( O(M \times N) \).

Этот алгоритм эффективно решает задачу без использования рекурсии и подходит для больших значений \( M \) и \( N \).

---
